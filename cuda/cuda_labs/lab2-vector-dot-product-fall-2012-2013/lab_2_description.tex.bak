\documentclass[11.5pt]{article}
\usepackage{graphics, graphicx, cite, fancybox, setspace}
\usepackage{amsfonts, amssymb, amsmath, latexsym, epic, eepic, url}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[letterpaper, left=1in, right=1in, top=1in, bottom=1in]{geometry}

\begin{document}

\title{ECEC-413: Introduction to Parallel Computer Architecture \\
Midterm Exam}
\author{Prof. Naga Kandasamy, ECE Department, Drexel University}
\maketitle %
\date{}

\noindent The exam is due February 9, 2011. You must work on this exam on your own.
\vspace{12pt}

\noindent 1. \textbf{(20 points)} \textbf{Vector Dot Product.} Given two $n$-element vectors \textbf{a} and \textbf{b}, their dot product $\textbf{a} \cdot \textbf{b}$ is given by
\begin{equation*}
\textbf{a} \cdot \textbf{b} = \sum_{i = 1}^{n}a_ib_i,
\end{equation*}
\noindent where $a_i$ and $b_i$ denote the $i^{\texttt{th}}$ elements of vectors \textbf{a} and \textbf{b}, respectively. \vspace{6pt}

\noindent The program provided to you accepts no arguments. It creates two randomly initialized vectors and computes their dot product using both the CPU and the GPU. The solution provided by the GPU is compared to that generated by the CPU. If the solutions match within a certain tolerance, the application will print out ``Test PASSED'' to the screen before exiting. \vspace{6pt}

\noindent Please answer the following questions:
\begin{itemize}
\item \textbf{(15 points)} Edit the \texttt{computeOnDevice()} function within the file \texttt{vector\_dot\_product.cu} to complete the functionality of vector dot product on the GPU. You may add multiple kernels to the \texttt{vector\_dot\_product\_kernel.cu} file to achieve this functionality. Do not change the source code elsewhere (except for adding timing-related code). The size of the vectors is guaranteed to be 10 million elements. The CUDA source files for this question are available in a zip file called \texttt{problem\_1.zip}.

\item \textbf{(5 points)} Provide a two/three page report describing: (1) the design of your kernel (use code or pseudocode to clarify the discussion); (2) the speedup achieved over the serial version; and (3) sensitivity of the kernel to thread-block size in terms of the execution time.
\end{itemize}

\noindent Provide a \underline{hard copy} of your report and email the files needed to run your code to me as a single zip file called \texttt{solution\_1.zip}.
\pagebreak

\noindent 2. \textbf{(30 points)} Consider the Gauss-Seidel equation solver discussed within the lecture notes on how to write parallel programs (see the file called \texttt{parallelization\_process.pdf} on webCT). You will find the source code corresponding to the reference implementation in the zip file \texttt{problem\_2.zip}. \vspace{6pt}

\noindent Recall that the order in which the grid points are updated in the sequential algorithm is not fundamental to the Gauss-Seidel solution method; it is simply one possible ordering that is convenient to program sequentially. Since the Gauss-Seidel method is not an exact solution method but rather iterates until convergence, we can update the grid points in a different order as long as we use updated values for grid points frequently enough, a technique called the \emph{Jacobi method} where we don't use updated values from the current iteration for any grid points but always use the values as they were at the end of the previous iteration. Using the sequential program as a starting point, develop a parallel version of the Jacobi method using an element-based decomposition strategy where each GPU thread is responsible for processing a single grid element. \vspace{6pt}

\noindent The program provided to you accepts no arguments. It creates a randomly initialized grid of $8192 \times 8192$ elements and applies the update rule to each element within the grid until the specified convergence criteria is satisfied. The solution provided by the GPU is compared to that generated by the CPU. If the solutions match within a certain tolerance, the application will print out ``Test PASSED'' to the screen before exiting. \vspace{6pt}

\noindent Answer the following questions. \vspace{6pt}
\begin{itemize}
\item \textbf{(10 points)} Edit the \texttt{compute\_on\_device()} function in the file \texttt{solver.cu} and the \texttt{solver\_kernel\_naive()} function in \texttt{solver\_kernel.cu} file to complete the functionality of the equation solver on the GPU using only \underline{global memory}. Do not change the source code elsewhere (except for adding timing-related code). The size of the grid is guaranteed to be $8192 \times 8192$ elements.

\item \textbf{(10 points)} Improve the performance of the kernel developed in the previous step by using \underline{shared memory} on the GPU. Edit the kernel function \texttt{solver\_kernel\_optimized()} in the \texttt{solver\_kernel.cu} file to complete the functionality.

\item \textbf{(5 points)} Provide a two/three page report describing: (1) the design of your kernel (use code or pseudocode to clarify the discussion); (2) the speedup obtained over the serial version for both the naive and optimized kernels; and (3) sensitivity of your kernels to thread-block size in terms of the execution time.
\end{itemize}

\noindent Provide a hard copy of your report and email me all of the files needed to run your code as a single zip file called \texttt{solution\_2.zip}.

\end{document}
